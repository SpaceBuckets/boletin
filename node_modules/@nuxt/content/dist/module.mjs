import fs from 'fs';
import { useLogger, defineNuxtModule, createResolver, resolveModule, addPlugin, templateUtils, addAutoImport, addComponentsDir, addTemplate } from '@nuxt/kit';
import defu from 'defu';
import { hash } from 'ohash';
import { resolve, join } from 'pathe';
import { listen } from 'listhen';
import 'unstorage/drivers/fs';
import 'unstorage/drivers/http';
import { WebSocketServer } from 'ws';

const name = "@nuxt/content";
const version = "2.0.1";

const CACHE_VERSION = 2;
const MOUNT_PREFIX = "content:source:";
const PROSE_TAGS = [
  "p",
  "a",
  "blockquote",
  "code-inline",
  "code",
  "em",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "img",
  "ul",
  "ol",
  "li",
  "strong",
  "table",
  "thead",
  "tbody",
  "td",
  "th",
  "tr"
];
function useContentMounts(nuxt, storages) {
  const key = (path, prefix = "") => `${MOUNT_PREFIX}${path.replace(/[/:]/g, "_")}${prefix.replace(/\//g, ":")}`;
  return storages.reduce((mounts, storage) => {
    if (typeof storage === "string") {
      mounts[key(storage)] = {
        name: storage,
        driver: "fs",
        prefix: "",
        base: resolve(nuxt.options.srcDir, storage)
      };
    }
    if (typeof storage === "object") {
      mounts[key(storage.name, storage.prefix)] = storage;
    }
    return mounts;
  }, {});
}
function createWebSocket() {
  const wss = new WebSocketServer({ noServer: true });
  const serve = (req, socket = req.socket, head = "") => wss.handleUpgrade(req, socket, head, (client) => wss.emit("connection", client, req));
  const broadcast = (data) => {
    data = JSON.stringify(data);
    for (const client of wss.clients) {
      try {
        client.send(data);
      } catch (err) {
      }
    }
  };
  return {
    serve,
    broadcast,
    close: () => {
      wss.clients.forEach((client) => client.close());
      return new Promise((resolve2) => wss.close(resolve2));
    }
  };
}
function processMarkdownOptions(options) {
  options.rehypePlugins = (options.rehypePlugins || []).map(resolveMarkdownPlugin).filter(Boolean);
  options.remarkPlugins = (options.remarkPlugins || []).map(resolveMarkdownPlugin).filter(Boolean);
  return options;
  function resolveMarkdownPlugin(plugin) {
    if (typeof plugin === "string") {
      plugin = [plugin, {}];
    }
    if (!Array.isArray(plugin)) {
      useLogger("@nuxt/content").warn("Plugin silently ignored:", plugin.name || plugin);
      return;
    }
    return plugin;
  }
}

const module = defineNuxtModule({
  meta: {
    name,
    version,
    configKey: "content",
    compatibility: {
      nuxt: "^3.0.0-rc.3"
    }
  },
  defaults: {
    base: "_content",
    watch: true,
    sources: ["content"],
    ignores: ["\\.", "-"],
    locales: [],
    defaultLocale: void 0,
    highlight: false,
    markdown: {
      tags: Object.fromEntries(PROSE_TAGS.map((t) => [t, `prose-${t}`]))
    },
    yaml: {},
    csv: {},
    navigation: {
      fields: []
    }
  },
  async setup(options, nuxt) {
    const { resolve } = createResolver(import.meta.url);
    const resolveRuntimeModule = (path) => resolveModule(path, { paths: resolve("./runtime") });
    const logger = useLogger("@nuxt/content");
    const contentContext = {
      transformers: [
        resolveRuntimeModule("./server/transformers/markdown"),
        resolveRuntimeModule("./server/transformers/yaml"),
        resolveRuntimeModule("./server/transformers/json"),
        resolveRuntimeModule("./server/transformers/csv"),
        resolveRuntimeModule("./server/transformers/path-meta")
      ],
      ...options
    };
    if (nuxt.options.vite !== false) {
      nuxt.options.vite = defu(nuxt.options.vite === true ? {} : nuxt.options.vite, {
        optimizeDeps: {
          include: ["html-tags"]
        }
      });
    }
    options.sources.forEach((source) => {
      if (typeof source === "string") {
        nuxt.options.ignore.push(join("content", "**"));
      }
    });
    addPlugin(resolveRuntimeModule("./plugin"));
    nuxt.hook("nitro:config", (nitroConfig) => {
      nitroConfig.handlers = nitroConfig.handlers || [];
      nitroConfig.handlers.push({
        method: "get",
        route: `/api/${options.base}/query/:qid`,
        handler: resolveRuntimeModule("./server/api/query")
      });
      nitroConfig.handlers.push({
        method: "get",
        route: `/api/${options.base}/query`,
        handler: resolveRuntimeModule("./server/api/query")
      });
      nitroConfig.handlers.push({
        method: "get",
        route: `/api/${options.base}/cache`,
        handler: resolveRuntimeModule("./server/api/cache")
      });
      if (!nuxt.options.dev) {
        nitroConfig.prerender.routes.push("/api/_content/cache");
      }
      const sources = useContentMounts(nuxt, contentContext.sources || []);
      nitroConfig.devStorage = Object.assign(nitroConfig.devStorage || {}, sources);
      nitroConfig.bundledStorage = nitroConfig.bundledStorage || [];
      nitroConfig.bundledStorage.push("/cache/content");
      nitroConfig.externals = defu(typeof nitroConfig.externals === "object" ? nitroConfig.externals : {}, {
        inline: [
          resolve("./runtime")
        ]
      });
      nitroConfig.alias["#content/server"] = resolveRuntimeModule("./server");
      nitroConfig.virtual = nitroConfig.virtual || {};
      nitroConfig.virtual["#content/virtual/transformers"] = [
        templateUtils.importSources(contentContext.transformers),
        `const transformers = [${contentContext.transformers.map(templateUtils.importName).join(", ")}]`,
        'export const getParser = (ext) => transformers.find(p => ext.match(new RegExp(p.extentions.join("|"),  "i")) && p.parse)',
        'export const getTransformers = (ext) => transformers.filter(p => ext.match(new RegExp(p.extentions.join("|"),  "i")) && p.transform)',
        "export default () => {}"
      ].join("\n");
    });
    addAutoImport([
      { name: "queryContent", as: "queryContent", from: resolveRuntimeModule("./composables/query") },
      { name: "withContentBase", as: "withContentBase", from: resolveRuntimeModule("./composables/utils") },
      { name: "useUnwrap", as: "useUnwrap", from: resolveRuntimeModule("./composables/utils") }
    ]);
    await addComponentsDir({
      path: resolve("./runtime/components"),
      pathPrefix: false,
      prefix: "",
      level: 999,
      global: true
    });
    addTemplate({
      filename: "types/content.d.ts",
      getContents: () => [
        "declare module '#content/server' {",
        `  const serverQueryContent: typeof import('${resolve("./runtime/server")}').serverQueryContent`,
        `  const parseContent: typeof import('${resolve("./runtime/server")}').parseContent`,
        "}"
      ].join("\n")
    });
    nuxt.hook("prepare:types", (options2) => {
      options2.references.push({ path: resolve(nuxt.options.buildDir, "types/content.d.ts") });
    });
    const globalComponents = resolve(nuxt.options.srcDir, "components/content");
    const dirStat = await fs.promises.stat(globalComponents).catch(() => null);
    if (dirStat && dirStat.isDirectory()) {
      logger.success("Using `~/components/content` for components in Markdown");
      nuxt.hook("components:dirs", (dirs) => {
        dirs.unshift({
          path: globalComponents,
          global: true,
          pathPrefix: false,
          prefix: ""
        });
      });
    } else {
      const componentsDir = resolve(nuxt.options.srcDir, "components/");
      const componentsDirStat = await fs.promises.stat(componentsDir).catch(() => null);
      if (componentsDirStat && componentsDirStat.isDirectory()) {
        logger.info("Please create `~/components/content` and restart the Nuxt server to use components in Markdown");
      }
    }
    if (options.navigation) {
      addAutoImport({ name: "fetchContentNavigation", as: "fetchContentNavigation", from: resolveRuntimeModule("./composables/navigation") });
      nuxt.hook("nitro:config", (nitroConfig) => {
        nitroConfig.handlers.push({
          method: "get",
          route: `/api/${options.base}/navigation/:qid`,
          handler: resolveRuntimeModule("./server/api/navigation")
        });
        nitroConfig.handlers.push({
          method: "get",
          route: `/api/${options.base}/navigation`,
          handler: resolveRuntimeModule("./server/api/navigation")
        });
      });
    }
    if (options.highlight) {
      contentContext.transformers.push(resolveRuntimeModule("./server/transformers/shiki"));
      nuxt.hook("nitro:config", (nitroConfig) => {
        nitroConfig.handlers.push({
          method: "post",
          route: `/api/${options.base}/highlight`,
          handler: resolveRuntimeModule("./server/api/highlight")
        });
      });
    }
    await nuxt.callHook("content:context", contentContext);
    contentContext.defaultLocale = contentContext.defaultLocale || contentContext.locales[0];
    const cacheIntegerity = hash({
      locales: options.locales,
      options: options.defaultLocale,
      markdown: options.markdown,
      hightlight: options.highlight
    });
    contentContext.markdown = processMarkdownOptions(contentContext.markdown);
    nuxt.options.runtimeConfig.public.content = defu(nuxt.options.runtimeConfig.public.content, {
      base: options.base,
      tags: contentContext.markdown.tags,
      highlight: options.highlight,
      wsUrl: ""
    });
    nuxt.options.runtimeConfig.content = {
      cacheVersion: CACHE_VERSION,
      cacheIntegerity,
      ...contentContext
    };
    if (!nuxt.options.dev || !options.watch) {
      return;
    }
    nuxt.hook("nitro:init", async (nitro) => {
      const ws = createWebSocket();
      nitro.hooks.hook("close", async () => {
        await ws.close();
      });
      const { server, url } = await listen(() => "Nuxt Content", { port: 4e3, showURL: false });
      server.on("upgrade", ws.serve);
      nitro.options.runtimeConfig.public.content.wsUrl = url.replace("http", "ws");
      await nitro.storage.watch((event, key) => {
        if (!key.startsWith(MOUNT_PREFIX)) {
          return;
        }
        key = key.substring(MOUNT_PREFIX.length);
        ws.broadcast({ event, key });
      });
    });
  }
});

export { module as default };
