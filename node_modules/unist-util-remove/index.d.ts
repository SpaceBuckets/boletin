export const remove: (<Tree extends import('unist').Node<import('unist').Data>>(
  node: Tree,
  options: RemoveOptions,
  test:
    | string
    | import('unist-util-is').Props
    | TestFunction<
        import('unist-util-visit-parents/complex-types').InclusiveDescendant<
          Tree,
          void
        >
      >
    | (
        | string
        | import('unist-util-is').Props
        | TestFunction<
            import('unist-util-visit-parents/complex-types').InclusiveDescendant<
              Tree,
              void
            >
          >
      )[]
) => Tree | null) &
  (<Tree_1 extends import('unist').Node<import('unist').Data>>(
    node: Tree_1,
    test:
      | string
      | import('unist-util-is').Props
      | TestFunction<
          import('unist-util-visit-parents/complex-types').InclusiveDescendant<
            Tree_1,
            void
          >
        >
      | (
          | string
          | import('unist-util-is').Props
          | TestFunction<
              import('unist-util-visit-parents/complex-types').InclusiveDescendant<
                Tree_1,
                void
              >
            >
        )[]
  ) => Tree_1 | null)
export type Node = import('unist').Node
export type Parent = import('unist').Parent
export type Type = import('unist-util-is').Type
export type Props = import('unist-util-is').Props
/**
 * Check if a node passes a test
 */
export type TestFunction<
  Tree extends import('unist').Node<import('unist').Data>
> = (
  node: Tree,
  index?: number | null | undefined,
  parent?: Parent | null | undefined
) => boolean | void
export type RemoveOptions = {
  /**
   * Whether to drop parent nodes if they had children, but all their children were filtered out test
   */
  cascade?: boolean | undefined
}
